"""
Student Agent Implementation for River and Stones Game

This file contains the essential utilities and template for implementing your AI agent.
Your task is to complete the StudentAgent class with intelligent move selection.

Game Rules:
- Goal: Get 4 of your stones into the opponent's scoring area
- Pieces can be stones or rivers (horizontal/vertical orientation)
- Actions: move, push, flip (stone↔river), rotate (river orientation)
- Rivers enable flow-based movement across the board

Your Task:
Implement the choose() method in the StudentAgent class to select optimal moves.
You may add any helper methods and modify the evaluation function as needed.
"""

import random
import copy
from typing import List, Dict, Any, Optional, Tuple
from abc import ABC, abstractmethod

# ==================== GAME UTILITIES ====================
# Essential utility functions for game state analysis


def in_bounds(x: int, y: int, rows: int, cols: int) -> bool:
    """Check if coordinates are within board boundaries."""
    return 0 <= x < cols and 0 <= y < rows


def score_cols_for(cols: int) -> List[int]:
    """Get the column indices for scoring areas."""
    w = 4
    start = max(0, (cols - w) // 2)
    return list(range(start, start + w))


def top_score_row() -> int:
    """Get the row index for Circle's scoring area."""
    return 2


def bottom_score_row(rows: int) -> int:
    """Get the row index for Square's scoring area."""
    return rows - 3


def is_opponent_score_cell(
    x: int, y: int, player: str, rows: int, cols: int, score_cols: List[int]
) -> bool:
    """Check if a cell is in the opponent's scoring area."""
    if player == "circle":
        return (y == bottom_score_row(rows)) and (x in score_cols)
    else:
        return (y == top_score_row()) and (x in score_cols)


def is_own_score_cell(
    x: int, y: int, player: str, rows: int, cols: int, score_cols: List[int]
) -> bool:
    """Check if a cell is in the player's own scoring area."""
    if player == "circle":
        return (y == top_score_row()) and (x in score_cols)
    else:
        return (y == bottom_score_row(rows)) and (x in score_cols)


def get_opponent(player: str) -> str:
    """Get the opponent player identifier."""
    return "square" if player == "circle" else "circle"


# ==================== generate moves ======================


def generate_1_step_moves(board, player, rows, cols, score_cols):
    """
    Generate simple 1-step moves for player's stones.
    """
    moves = []
    directions = [(1, 0), (-1, 0), (0, 1), (0, -1)]

    for y in range(rows):
        for x in range(cols):
            piece = board[y][x]
            if not piece or piece.owner != player:
                continue

            for dx, dy in directions:
                nx, ny = x + dx, y + dy
                if not in_bounds(nx, ny, rows, cols):
                    continue
                if is_opponent_score_cell(nx, ny, player, rows, cols, score_cols):
                    continue
                if board[ny][nx] is None:
                    moves.append({"action": "move", "from": [x, y], "to": [nx, ny]})

    return moves


def generate_stone_pushes(board, player, rows, cols, score_cols):
    """
    Generate push moves where a stone pushes an adjacent opponent piece.
    """
    moves = []
    directions = [(1, 0), (-1, 0), (0, 1), (0, -1)]

    for y in range(rows):
        for x in range(cols):
            piece = board[y][x]
            if not piece or piece.owner != player or piece.side != "stone":
                continue

            for dx, dy in directions:
                nx, ny = x + dx, y + dy
                if not in_bounds(nx, ny, rows, cols):
                    continue
                target = board[ny][nx]
                if not target or target.owner == player:
                    continue

                px, py = nx + dx, ny + dy
                if not in_bounds(px, py, rows, cols):
                    continue
                if board[py][px] is not None:
                    continue
                if is_opponent_score_cell(nx, ny, player, rows, cols, score_cols):
                    continue
                if is_own_score_cell(px, py, player, rows, cols, score_cols):
                    continue

                moves.append(
                    {
                        "action": "push",
                        "from": [x, y],
                        "to": [nx, ny],
                        "pushed_to": [px, py],
                    }
                )

    return moves


def generate_stone_flips(board, player, rows, cols, score_cols):
    """
    Generate flips of stones into rivers.
    """
    moves = []
    for y in range(rows):
        for x in range(cols):
            piece = board[y][x]
            if not piece or piece.owner != player or piece.side != "stone":
                continue

            for orientation in ("horizontal", "vertical"):
                temp = copy.deepcopy(board)
                temp[y][x].side = "river"
                temp[y][x].orientation = orientation
                flow = agent_river_flow(
                    temp, x, y, x, y, player, rows, cols, score_cols
                )

                if not any(
                    is_opponent_score_cell(dx, dy, player, rows, cols, score_cols)
                    for dx, dy in flow
                ):
                    moves.append(
                        {"action": "flip", "from": [x, y], "orientation": orientation}
                    )

    return moves


def generate_river_flips(board, player, rows, cols, score_cols):
    """
    Generate flips of river back to stone.
    """
    moves = []
    for y in range(rows):
        for x in range(cols):
            piece = board[y][x]
            if not piece or piece.owner != player or piece.side != "river":
                continue
            moves.append({"action": "flip", "from": [x, y]})
    return moves


def generate_river_rotates(board, player, rows, cols, score_cols):
    """
    Generate rotations of river orientation.
    """
    moves = []
    for y in range(rows):
        for x in range(cols):
            piece = board[y][x]
            if not piece or piece.owner != player or piece.side != "river":
                continue

            new_orientation = (
                "vertical" if piece.orientation == "horizontal" else "horizontal"
            )
            temp = copy.deepcopy(board)
            temp[y][x].orientation = new_orientation
            flow = agent_river_flow(temp, x, y, x, y, player, rows, cols, score_cols)

            if not any(
                is_opponent_score_cell(dx, dy, player, rows, cols, score_cols)
                for dx, dy in flow
            ):
                moves.append({"action": "rotate", "from": [x, y]})

    return moves


def generate_stone_in_river_flows(board, player, rows, cols, score_cols):
    """
    Generate moves where a stone enters a river and flows.
    """
    moves = []
    for y in range(rows):
        for x in range(cols):
            piece = board[y][x]
            if not piece or piece.owner != player or piece.side != "stone":
                continue
            
            flow = agent_river_flow(board, x, y, x, y, player, rows, cols, score_cols)
            for fx, fy in flow:
                if not is_opponent_score_cell(fx, fy, player, rows, cols, score_cols):
                    moves.append(
                        {"action": "move", "from": [x, y], "to": [fx, fy]}
                    )

    return moves

def generate_river_moves(board, player, rows, cols, score_cols):
    """
    Generate moves where a river enters a river and flows.
    """
    moves = []
    for y in range(rows):
        for x in range(cols):
            piece = board[y][x]
            if not piece or piece.owner != player or piece.side != "river":
                continue

            flow = agent_river_flow(board, x, y, x, y, player, rows, cols, score_cols)
            for fx, fy in flow:
                if not is_opponent_score_cell(fx, fy, player, rows, cols, score_cols):
                    moves.append(
                        {"action": "move", "from": [x, y], "to": [fx, fy]}
                    )

    return moves
    # """
    # Generate moves where river pieces slide along other river flow.
    # """
    # moves = []

    # for y in range(rows):
    #     for x in range(cols):
    #         piece = board[y][x]
    #         if not piece or piece.owner != player or piece.side != "river":
    #             continue

    #         # Get all destinations along the river flow
    #         flow = agent_river_flow(board, x, y, x, y, player, rows, cols, score_cols)

    #         for fx, fy in flow:
    #             # Skip score areas
    #             if is_opponent_score_cell(fx, fy, player, rows, cols, score_cols):
    #                 continue

    #             moves.append({"action": "move", "from": [x, y], "to": [fx, fy]})

    # return moves


def generate_river_pushes(board, player, rows, cols, score_cols):
    """
    Generate moves where a river piece pushes an adjacent opponent stone along its river flow.
    """
    moves = []
    for y in range(rows):
        for x in range(cols):
            river = board[y][x]
            if not river or river.owner != player or river.side != "river":
                continue

            # Get all possible destinations along the river flow
            flow = agent_river_flow(
                board, x, y, x, y, player, rows, cols, score_cols, river_push=True
            )

            # Check only stones adjacent to the river piece
            for dx, dy in [(1, 0), (-1, 0), (0, 1), (0, -1)]:
                sx, sy = x + dx, y + dy
                if not in_bounds(sx, sy, rows, cols):
                    continue
                stone = board[sy][sx]
                if (
                    not stone
                    or stone.owner == player
                    or getattr(stone, "side", "stone") != "stone"
                ):
                    continue

                # Place pushed stone only in empty cells along the river flow
                for px, py in flow:
                    if (
                        board[py][px] is None
                        and not is_opponent_score_cell(
                            px, py, player, rows, cols, score_cols
                        )
                        and not is_own_score_cell(
                            px, py, player, rows, cols, score_cols
                        )
                    ):
                        moves.append(
                            {
                                "action": "push",
                                "from": [x, y],  # river piece
                                "to": [sx, sy],  # adjacent opponent stone
                                "pushed_to": [px, py],  # where stone ends up
                            }
                        )
    return moves


def generate_all_moves(board, player, rows, cols, score_cols):
    moves = []
    moves.extend(generate_1_step_moves(board, player, rows, cols, score_cols))
    moves.extend(generate_stone_pushes(board, player, rows, cols, score_cols))
    moves.extend(generate_stone_flips(board, player, rows, cols, score_cols))
    moves.extend(generate_river_flips(board, player, rows, cols, score_cols))
    moves.extend(generate_river_rotates(board, player, rows, cols, score_cols))
    moves.extend(generate_stone_in_river_flows(board, player, rows, cols, score_cols))
    moves.extend(generate_river_moves(board, player, rows, cols, score_cols))
    moves.extend(generate_river_pushes(board, player, rows, cols, score_cols))
    return moves


# ==================== BOARD EVALUATION ====================


def eval_stone_progress(board, player, rows, cols):
    """
    Reward stones that are closer to the opponent's goal row.
    Simple positional scoring.
    """
    score = 0
    for y in range(rows):
        for x in range(cols):
            piece = board[y][x]
            if piece and piece.owner == player and piece.side == "stone":
                # Basic positional scoring
                if player == "circle":
                    score += rows - y  # circle moves downward
                else:
                    score += y  # cross moves upward
    return score


def eval_central_positions(board, player, cols):
    score = 0
    mid_col = cols // 2
    for row in board:
        for x in range(cols):
            piece = row[x]
            if piece and piece.owner == player and piece.side == "stone":
                score += 1 * (mid_col - abs(mid_col - x))  # closer to center = higher
    return score


def eval_stones_in_goal(board, player, score_cols):
    """
    Bonus for stones already in goal columns.
    """
    score = 0
    for y in range(len(board)):
        for x in score_cols:
            piece = board[y][x]
            if piece and piece.owner == player and piece.side == "stone":
                score += 1  # fixed bonus
    return score


def eval_stones_on_river(board, player):
    """
    Bonus for stones currently on river cells.
    """
    score = 0
    for row in board:
        for piece in row:
            if piece and piece.owner == player and piece.side == "river":
                score += 1  # small bonus
    return score


def eval_threats(board, player, rows, cols):
    """
    Penalize stones that are next to opponent stones.
    """
    opponent = "square" if player == "circle" else "circle"
    directions = [(1, 0), (-1, 0), (0, 1), (0, -1)]
    score = 0
    for y in range(rows):
        for x in range(cols):
            piece = board[y][x]
            if piece and piece.owner == player:
                for dx, dy in directions:
                    nx, ny = x + dx, y + dy
                    if 0 <= nx < cols and 0 <= ny < rows:
                        neighbor = board[ny][nx]
                        if neighbor and neighbor.owner == opponent:
                            score += 1  # small penalty
    return score


def eval_instant_score_potential(board, player, rows, cols, score_cols):
    """
    Reward stones that can reach goal columns in 1 river flow move.
    """
    score = 0
    for y in range(rows):
        for x in range(cols):
            piece = board[y][x]
            if piece and piece.owner == player and piece.side == "stone":
                # Check all river flows from adjacent rivers
                directions = [(1, 0), (-1, 0), (0, 1), (0, -1)]
                for dx, dy in directions:
                    nx, ny = x + dx, y + dy
                    if in_bounds(nx, ny, rows, cols):
                        neighbor = board[ny][nx]
                        if (
                            neighbor
                            and neighbor.owner == player
                            and neighbor.side == "river"
                        ):
                            flow = agent_river_flow(
                                board, nx, ny, x, y, player, rows, cols, score_cols
                            )
                            if any(d[1] in score_cols for d in flow):
                                score += 1  # big bonus for potential instant scoring
    return score


def evaluate_simple(board, player, rows, cols, score_cols):
    """
    Combine all simple evaluation functions with given weights.
    """
    weights = {
        "progress": 10,  # Reward moving stones toward opponent's goal
        "goal": 50,  # Strong bonus for stones already in goal columns
        "river": 0.1,  # Small bonus for stones on river
        "threat": -0.2,  # Slight penalty for being next to opponent
        "central": 10,  # Encourage central positioning
        "instant_score": 20,  # High reward for stones that can score via river in 1 move
    }
    total = 0
    total += weights["progress"] * eval_stone_progress(board, player, rows, cols)
    total += weights["goal"] * eval_stones_in_goal(board, player, score_cols)
    total += weights["river"] * eval_stones_on_river(board, player)
    total += weights["threat"] * eval_threats(board, player, rows, cols)
    total += weights["central"] * eval_central_positions(board, player, cols)
    total += weights["instant_score"] * eval_instant_score_potential(
        board, player, rows, cols, score_cols
    )
    return total


def count_stones_in_scoring_area(
    board: List[List[Any]], player: str, rows: int, cols: int, score_cols: List[int]
) -> int:
    """Count how many stones a player has in their scoring area."""
    count = 0

    if player == "circle":
        score_row = top_score_row()
    else:
        score_row = bottom_score_row(rows)

    for x in score_cols:
        if in_bounds(x, score_row, rows, cols):
            piece = board[score_row][x]
            if piece and piece.owner == player and piece.side == "stone":
                count += 1

    return count


def basic_evaluate_board(
    board: List[List[Any]], player: str, rows: int, cols: int, score_cols: List[int]
) -> float:
    """
    Basic board evaluation function.

    Returns a score where higher values are better for the given player.
    Students can use this as a starting point and improve it.
    """
    score = 0.0
    opponent = get_opponent(player)

    # Count stones in scoring areas
    player_scoring_stones = count_stones_in_scoring_area(
        board, player, rows, cols, score_cols
    )
    opponent_scoring_stones = count_stones_in_scoring_area(
        board, opponent, rows, cols, score_cols
    )

    score += player_scoring_stones * 100
    score -= opponent_scoring_stones * 100

    # Count total pieces and positional factors
    for y in range(rows):
        for x in range(cols):
            piece = board[y][x]
            if piece and piece.owner == player and piece.side == "stone":
                # Basic positional scoring
                if player == "circle":
                    score += (rows - y) * 0.1
                else:
                    score += y * 0.1

    return score


def agent_apply_move(
    board,
    move: Dict[str, Any],
    player: str,
    rows: int,
    cols: int,
    score_cols: List[int],
) -> Tuple[bool, str]:
    """
    Apply a move to a board copy for simulation purposes.

    Args:
        board: Board state to modify
        move: Move dictionary
        player: Current player
        rows, cols: Board dimensions
        score_cols: Scoring column indices

    Returns:
        (success: bool, message: str)
    """
    action = move.get("action")

    if action == "move":
        return _apply_move_action(board, move, player, rows, cols, score_cols)
    elif action == "push":
        return _apply_push_action(board, move, player, rows, cols, score_cols)
    elif action == "flip":
        return _apply_flip_action(board, move, player, rows, cols, score_cols)
    elif action == "rotate":
        return _apply_rotate_action(board, move, player, rows, cols, score_cols)

    return False, "unknown action"


def _apply_move_action(board, move, player, rows, cols, score_cols):
    """Apply a move action."""
    fr = move.get("from")
    to = move.get("to")
    if not fr or not to:
        return False, "bad move format"

    fx, fy = int(fr[0]), int(fr[1])
    tx, ty = int(to[0]), int(to[1])

    if not in_bounds(fx, fy, rows, cols) or not in_bounds(tx, ty, rows, cols):
        return False, "out of bounds"

    if is_opponent_score_cell(tx, ty, player, rows, cols, score_cols):
        return False, "cannot move into opponent score cell"

    piece = board[fy][fx]
    if piece is None or piece.owner != player:
        # if piece is None:
        #     return False, "None piece"
        # else:
        #     return False, "owner diff"
        return False, "invalid piece"

    if board[ty][tx] is None:
        # Simple move
        board[ty][tx] = piece
        board[fy][fx] = None
        return True, "moved"

    # Move with push
    pushed_to = move.get("pushed_to")
    if not pushed_to:
        return False, "destination occupied; pushed_to required"

    ptx, pty = int(pushed_to[0]), int(pushed_to[1])
    dx, dy = tx - fx, ty - fy

    if (ptx, pty) != (tx + dx, ty + dy):
        return False, "invalid pushed_to"

    if not in_bounds(ptx, pty, rows, cols):
        return False, "pushed_to out of bounds"

    if is_opponent_score_cell(ptx, pty, player, rows, cols, score_cols):
        return False, "cannot push into opponent score"

    if board[pty][ptx] is not None:
        return False, "pushed_to not empty"

    board[pty][ptx] = board[ty][tx]
    board[ty][tx] = piece
    board[fy][fx] = None
    return True, "moved with push"


def _apply_push_action(board, move, player, rows, cols, score_cols):
    """Apply a push action."""
    fr = move.get("from")
    to = move.get("to")
    pushed_to = move.get("pushed_to")

    if not fr or not to or not pushed_to:
        return False, "bad push format"

    fx, fy = int(fr[0]), int(fr[1])
    tx, ty = int(to[0]), int(to[1])
    px, py = int(pushed_to[0]), int(pushed_to[1])

    if is_opponent_score_cell(
        tx, ty, player, rows, cols, score_cols
    ) or is_opponent_score_cell(px, py, player, rows, cols, score_cols):
        return False, "push would move into opponent score cell"

    if not (
        in_bounds(fx, fy, rows, cols)
        and in_bounds(tx, ty, rows, cols)
        and in_bounds(px, py, rows, cols)
    ):
        return False, "out of bounds"

    piece = board[fy][fx]
    if piece is None or piece.owner != player:
        return False, "invalid piece"

    if board[ty][tx] is None:
        return False, "'to' must be occupied"

    if board[py][px] is not None:
        return False, "pushed_to not empty"

    board[py][px] = board[ty][tx]
    board[ty][tx] = board[fy][fx]
    board[fy][fx] = None
    return True, "pushed"


def _apply_flip_action(board, move, player, rows, cols, score_cols):
    """Apply a flip action."""
    fr = move.get("from")
    if not fr:
        return False, "bad flip format"

    fx, fy = int(fr[0]), int(fr[1])
    piece = board[fy][fx]

    if piece is None or piece.owner != player:
        return False, "invalid piece"

    if piece.side == "stone":
        # Stone to river
        orientation = move.get("orientation")
        if orientation not in ("horizontal", "vertical"):
            return False, "stone->river needs orientation"

        # Check if new river would allow flow into opponent score
        board[fy][fx].side = "river"
        board[fy][fx].orientation = orientation
        flow = agent_river_flow(board, fx, fy, fx, fy, player, rows, cols, score_cols)

        # Revert for safety check
        board[fy][fx].side = "stone"
        board[fy][fx].orientation = None

        for dx, dy in flow:
            if is_opponent_score_cell(dx, dy, player, rows, cols, score_cols):
                return False, "flip would allow flow into opponent score cell"

        # Apply flip
        board[fy][fx].side = "river"
        board[fy][fx].orientation = orientation
        return True, "flipped to river"
    else:
        # River to stone
        board[fy][fx].side = "stone"
        board[fy][fx].orientation = None
        return True, "flipped to stone"


def _apply_rotate_action(board, move, player, rows, cols, score_cols):
    """Apply a rotate action."""
    fr = move.get("from")
    if not fr:
        return False, "bad rotate format"

    fx, fy = int(fr[0]), int(fr[1])
    piece = board[fy][fx]

    if piece is None or piece.owner != player or piece.side != "river":
        return False, "invalid rotate"

    # Try rotation
    old_orientation = piece.orientation
    piece.orientation = "horizontal" if piece.orientation == "vertical" else "vertical"

    # Check flow safety after rotation
    flow = agent_river_flow(board, fx, fy, fx, fy, player, rows, cols, score_cols)

    for dx, dy in flow:
        if is_opponent_score_cell(dx, dy, player, rows, cols, score_cols):
            # Revert rotation
            piece.orientation = old_orientation
            return False, "rotate would allow flow into opponent score cell"

    return True, "rotated"


def agent_river_flow(
    board,
    rx: int,
    ry: int,
    sx: int,
    sy: int,
    player: str,
    rows: int,
    cols: int,
    score_cols: List[int],
    river_push: bool = False,
) -> List[Tuple[int, int]]:
    """
    Simulate river flow from a given position.

    Args:
        board: Current board state
        rx, ry: River entry point
        sx, sy: Source position (where piece is moving from)
        player: Current player
        rows, cols: Board dimensions
        score_cols: Scoring column indices
        river_push: Whether this is for a river push move

    Returns:
        List of (x, y) coordinates where the piece can end up via river flow
    """
    destinations = []
    visited = set()
    queue = [(rx, ry)]

    while queue:
        x, y = queue.pop(0)
        if (x, y) in visited or not in_bounds(x, y, rows, cols):
            continue
        visited.add((x, y))

        cell = board[y][x]
        if river_push and x == rx and y == ry:
            cell = board[sy][sx]

        if cell is None:
            if is_opponent_score_cell(x, y, player, rows, cols, score_cols):
                # Block entering opponent score cell
                pass
            else:
                destinations.append((x, y))
            continue

        if getattr(cell, "side", "stone") != "river":
            continue

        # River flow directions
        dirs = (
            [(1, 0), (-1, 0)] if cell.orientation == "horizontal" else [(0, 1), (0, -1)]
        )

        for dx, dy in dirs:
            nx, ny = x + dx, y + dy
            while in_bounds(nx, ny, rows, cols):
                if is_opponent_score_cell(nx, ny, player, rows, cols, score_cols):
                    break

                next_cell = board[ny][nx]
                if next_cell is None:
                    destinations.append((nx, ny))
                    nx += dx
                    ny += dy
                    continue

                if nx == sx and ny == sy:
                    nx += dx
                    ny += dy
                    continue

                if getattr(next_cell, "side", "stone") == "river":
                    queue.append((nx, ny))
                    break
                break

    # Remove duplicates
    unique_destinations = []
    seen = set()
    for d in destinations:
        if d not in seen:
            seen.add(d)
            unique_destinations.append(d)

    return unique_destinations


def simulate_move(
    board: List[List[Any]],
    move: Dict[str, Any],
    player: str,
    rows: int,
    cols: int,
    score_cols: List[int],
) -> Tuple[bool, Any]:
    """
    Simulate a move on a copy of the board.

    Returns:
        (success: bool, new_board or error_message)
    """

    board_copy = copy.deepcopy(board)
    success, message = agent_apply_move(
        board_copy, move, player, rows, cols, score_cols
    )

    if success:
        return True, board_copy
    else:
        return False, message


def evaluate(
    board: List[List[Any]], player: str, rows: int, cols: int, score_cols: List[int]
):
    """
    Basic board evaluation function.

    Returns a score where higher values are better for the given player.
    Students can use this as a starting point and improve it.
    """
    score = 0.0
    opponent = get_opponent(player)

    # Count stones in scoring areas
    player_scoring_stones = count_stones_in_scoring_area(
        board, player, rows, cols, score_cols
    )
    opponent_scoring_stones = count_stones_in_scoring_area(
        board, opponent, rows, cols, score_cols
    )

    score += player_scoring_stones * 100
    score -= opponent_scoring_stones * 100

    # Count total pieces and positional factors
    for y in range(rows):
        for x in range(cols):
            piece = board[y][x]
            if piece and piece.owner == player and piece.side == "stone":
                # Basic positional scoring
                if player == "circle":
                    score += (rows - y) * 0.1
                else:
                    score += y * 0.1

    return 1


def minimax_move(
    board: List[List[Any]],
    player: str,
    rows: int,
    cols: int,
    score_cols: List[int],
    moves: List[Dict[str, Any]],
) -> Dict[str, Any]:

    maxVal = -float("inf")
    maxMove = None
    opponent = get_opponent(player)
    for move in moves:
        (success, result) = simulate_move(board, move, player, rows, cols, score_cols)
        if success:
            child = result
            child_moves = generate_all_moves(child, opponent, rows, cols, score_cols)
            childVal = maxValue(
                child,
                opponent,
                rows,
                cols,
                score_cols,
                child_moves,
                -float("inf"),
                float("inf"),
                1,
            )
            if maxVal < childVal:
                maxMove = move
        else:
            print("error is here334")
            print("Error:", result)
            return None
    print("move", maxMove)
    return maxMove


def minValue(
    board: List[List[Any]],
    player: str,
    rows: int,
    cols: int,
    score_cols: List[int],
    moves: List[Dict[str, Any]],
    alpha: float,
    beta: float,
    depth: int,
) -> float:
    if depth == 0:
        return evaluate_simple(board, player, rows, cols, score_cols)
    print("d", depth)

    minVal = float("inf")
    opponent = get_opponent(player)

    for move in moves:
        (success, result) = simulate_move(board, move, player, rows, cols, score_cols)
        if success:
            child = result
            child_moves = generate_all_moves(child, opponent, rows, cols, score_cols)
            childVal = maxValue(
                child,
                opponent,
                rows,
                cols,
                score_cols,
                child_moves,
                alpha,
                beta,
                depth - 1,
            )
            beta = min(beta, childVal)
            minVal = min(minVal, childVal)
            if alpha >= beta:
                break
        else:
            print("error is here508")
            print("Error:", result)
            return float("inf")
    return minVal


def maxValue(
    board: List[List[Any]],
    player: str,
    rows: int,
    cols: int,
    score_cols: List[int],
    moves: List[Dict[str, Any]],
    alpha: float,
    beta: float,
    depth: int,
) -> float:
    if depth == 0:
        return evaluate_simple(board, player, rows, cols, score_cols)
    print("d", depth)

    maxVal = -float("inf")
    opponent = get_opponent(player)

    for move in moves:

        (success, result) = simulate_move(board, move, player, rows, cols, score_cols)
        if success:
            child = result
            child_moves = generate_all_moves(child, opponent, rows, cols, score_cols)
            childVal = minValue(
                child,
                opponent,
                rows,
                cols,
                score_cols,
                child_moves,
                alpha,
                beta,
                depth - 1,
            )
            alpha = max(alpha, childVal)
            maxVal = max(maxVal, childVal)
            if alpha >= beta:
                break
        else:
            print("error is here401", move)
            print("Error:", result)
            return -float("inf")
    return maxVal


# ==================== BASE AGENT CLASS ====================


class BaseAgent(ABC):
    """
    Abstract base class for all agents.
    """

    def __init__(self, player: str):
        """Initialize agent with player identifier."""
        self.player = player
        self.opponent = get_opponent(player)

    @abstractmethod
    def choose(
        self, board: List[List[Any]], rows: int, cols: int, score_cols: List[int]
    ) -> Optional[Dict[str, Any]]:
        """
        Choose the best move for the current board state.

        Args:
            board: 2D list representing the game board
            rows, cols: Board dimensions
            score_cols: List of column indices for scoring areas

        Returns:
            Dictionary representing the chosen move, or None if no moves available
        """
        pass


# ==================== STUDENT AGENT IMPLEMENTATION ====================


class StudentAgent(BaseAgent):
    """
    Student Agent Implementation

    TODO: Implement your AI agent for the River and Stones game.
    The goal is to get 4 of your stones into the opponent's scoring area.

    You have access to these utility functions:
    - generate_all_moves(): Get all legal moves for current player
    - basic_evaluate_board(): Basic position evaluation
    - simulate_move(): Test moves on board copy
    - count_stones_in_scoring_area(): Count stones in scoring positions
    """

    def __init__(self, player: str):
        super().__init__(player)
        # TODO: Add any initialization you need

    def choose(
        self, board: List[List[Any]], rows: int, cols: int, score_cols: List[int]
    ) -> Optional[Dict[str, Any]]:
        """
        Choose the best move for the current board state.

        Args:
            board: 2D list representing the game board
            rows, cols: Board dimensions
            score_cols: Column indices for scoring areas

        Returns:
            Dictionary representing your chosen move
        """
        moves = generate_all_moves(board, self.player, rows, cols, score_cols)

        my_move = minimax_move(board, self.player, rows, cols, score_cols, moves)

        if not moves:
            return None

        # TODO: Replace random selection with your AI algorithm
        return my_move


# ==================== TESTING HELPERS ====================


def test_student_agent():
    """
    Basic test to verify the student agent can be created and make moves.
    """
    print("Testing StudentAgent...")

    try:
        from gameEngine import default_start_board, DEFAULT_ROWS, DEFAULT_COLS

        rows, cols = DEFAULT_ROWS, DEFAULT_COLS
        score_cols = score_cols_for(cols)
        board = default_start_board(rows, cols)

        agent = StudentAgent("circle")
        move = agent.choose(board, rows, cols, score_cols)

        if move:
            print("✓ Agent successfully generated a move")
        else:
            print("✗ Agent returned no move")

    except ImportError:
        agent = StudentAgent("circle")
        print("✓ StudentAgent created successfully")


if __name__ == "__main__":
    # Run basic test when file is executed directly
    test_student_agent()
