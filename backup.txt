def get_river_flow_destinations(board:List[List[Optional[Piece]]],
                                rx:int, ry:int, sx:int, sy:int, player:str,
                                rows:int, cols:int, score_cols:List[int],
                                river_push:bool=False) -> List[Tuple[int,int]]:
    destinations=[]; visited=set(); queue=[(rx,ry)]
    while queue:
        x,y = queue.pop(0)
        if (x,y) in visited or not in_bounds(x,y,rows,cols): continue
        visited.add((x,y))
        cell = board[y][x]
        if river_push and x==rx and y==ry:
            cell = board[sy][sx]
        if cell is None:
            if is_opponent_score_cell(x,y,player,rows,cols,score_cols):
                # block entering opponent score
                pass
            else:
                destinations.append((x,y))
            continue
        if cell.side != "river":
            continue
        dirs = [(1,0),(-1,0)] if cell.orientation == "horizontal" else [(0,1),(0,-1)]
        for dx,dy in dirs:
            nx, ny = x+dx, y+dy
            while in_bounds(nx,ny,rows,cols):
                if is_opponent_score_cell(nx,ny,player,rows,cols,score_cols):
                    break
                next_cell = board[ny][nx]
                if next_cell is None:
                    destinations.append((nx,ny)); nx += dx; ny += dy; continue
                if nx==sx and ny==sy:
                    nx += dx; ny += dy; continue
                if next_cell.side == "river":
                    queue.append((nx,ny)); break
                break
    out=[]; seen=set()
    for d in destinations:
        if d not in seen:
            seen.add(d); out.append(d)
    return out


def generate_all_moves(board:List[List[Optional[Piece]]],
                       player:str, rows:int, cols:int, score_cols:List[int]) -> List[Dict[str,Any]]:
    # This is a convenience implementation; agents have their own generators,
    # but main provides this as well for reference or alternative usage.
    moves=[]
    dirs=[(1,0),(-1,0),(0,1),(0,-1)]
    for y in range(rows):
        for x in range(cols):
            p = board[y][x]
            if not p or p.owner != player: continue
            if p.side == "stone":
                for dx,dy in dirs:
                    nx,ny = x+dx,y+dy
                    if not in_bounds(nx,ny,rows,cols): continue
                    if is_opponent_score_cell(nx,ny,player,rows,cols,score_cols): continue
                    if board[ny][nx] is None:
                        moves.append({"action":"move","from":[x,y],"to":[nx,ny]})
                    else:
                        target = board[ny][nx]
                        if target.side == "river":
                            # moves that flow through the river
                            flow = agent_river_flow(board, nx, ny, x, y, player, rows, cols, score_cols)
                            for d in flow:
                                moves.append({"action":"move","from":[x,y],"to":d})
                        else:
                            # moves to push the stone pieces (can push self and opponent pieces both)
                            px,py = nx+dx, ny+dy
                            if in_bounds(px,py,rows,cols) and board[py][px] is None and not is_opponent_score_cell(px,py,target.owner,rows,cols,score_cols):
                                moves.append({"action":"push","from":[x,y],"to":[nx,ny],"pushed_to":[px,py]})
                # flips
                for ori in ("horizontal","vertical"):
                    p.side="river"; p.orientation=ori
                    moves.append({"action":"flip","from":[x,y],"orientation":ori})
            else:
                for dx,dy in dirs:
                    nx,ny = x+dx,y+dy
                    if not in_bounds(nx,ny,rows,cols): continue
                    if is_opponent_score_cell(nx,ny,player,rows,cols,score_cols): continue
                    if board[ny][nx] is None:
                        moves.append({"action":"move","from":[x,y],"to":[nx,ny]})
                    else:
                        target = board[ny][nx]
                        if target.side == "river":
                            # moves that flow through the river
                            flow = agent_river_flow(board, nx, ny, x, y, player, rows, cols, score_cols)
                            for d in flow:
                                moves.append({"action":"move","from":[x,y],"to":d})
                        else:
                            # moves to push the stone pieces (can push self and opponent pieces both)
                            px,py = nx+dx, ny+dy
                            if in_bounds(px,py,rows,cols) and board[py][px] is None and not is_opponent_score_cell(px,py,target.owner,rows,cols,score_cols):
                                moves.append({"action":"push","from":[x,y],"to":[nx,ny],"pushed_to":[px,py]})
                # flip to stone side
                moves.append({"action":"flip","from":[x,y]})
                # rotate
                new_ori = "vertical" if p.orientation=="horizontal" else "horizontal"
                p.orientation = new_ori
                moves.append({"action":"rotate","from":[x,y]})
    return moves

def generate_heuristic_moves(board, player, rows, cols, score_cols):
    moves = generate_all_moves(board,player,rows,cols,score_cols)
    
    # moves.extend(generate_river_moves(board, player, rows, cols, score_cols))
    # moves.extend(generate_stone_in_river_flows(board, player, rows, cols, score_cols))
    # moves.extend(generate_stone_flips(board, player, rows, cols, score_cols))
    # moves.extend(generate_river_flips(board, player, rows, cols, score_cols))
    # moves.extend(generate_river_rotates(board, player, rows, cols, score_cols))
    # moves.extend(generate_river_pushes(board, player, rows, cols, score_cols))
    # moves.extend(generate_stone_pushes(board, player, rows, cols, score_cols))
    # moves.extend(generate_1_step_moves(board, player, rows, cols, score_cols))

    river_moves = [m for m in moves if m["action"] in ("flip", "rotate")]
    river_moves = sorted(river_moves, key=lambda m: score_flow_move(m, board, player, rows, cols, score_cols), reverse=True)
    river_moves = river_moves[:5]

    moves_with_to = [m for m in moves if m["action"] in ("push","move")]
    moves_with_to = sorted(moves_with_to,key=lambda m: score_move(m, board, player, rows, cols, score_cols),reverse=True)
    moves_with_to = moves_with_to[:5]

    moves = river_moves + moves_with_to
    # moves = moves[:10]
    
    return moves
def count_all_moves(board, player, rows, cols, score_cols):
    moves = generate_all_moves(board,player,rows,cols,score_cols)
    # moves.extend(generate_river_moves(board, player, rows, cols, score_cols))
    # moves.extend(generate_stone_in_river_flows(board, player, rows, cols, score_cols))
    # moves.extend(generate_stone_flips(board, player, rows, cols, score_cols))
    # moves.extend(generate_river_flips(board, player, rows, cols, score_cols))
    # moves.extend(generate_river_rotates(board, player, rows, cols, score_cols))
    # moves.extend(generate_river_pushes(board, player, rows, cols, score_cols))
    # moves.extend(generate_stone_pushes(board, player, rows, cols, score_cols))
    # moves.extend(generate_1_step_moves(board, player, rows, cols, score_cols))

    # river_moves = [m for m in moves if m["action"] in ("flip", "rotate")]
    # river_moves = sorted(river_moves, key=lambda m: score_flow_move(m, board, player, rows, cols, score_cols), reverse=True)

    # moves_with_to = [m for m in moves if "to" in m]
    # moves_with_to = sorted(moves_with_to,key=lambda m: score_move(m, board, player, rows, cols, score_cols),reverse=True)

    # moves = river_moves + moves_with_to

    return len(moves)
